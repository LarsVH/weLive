import ~.iterMap;
import ~.weLiveLocal;
import ~.weLiveRemote;
import ~.playBoard;
import ~.peerElection;
import ~.misc;
import /.at.lang.futures exclude seconds,minutes,millisec;
import /.at.support.timer;

//DIRTY CONSTANTS
def rows := 6;
def cols := 4;
def playerDetectionTime := seconds(5);

deftype Player;
deftype Board;

def makeWeLive(){
	object:{
		// Id of this player
		def ID := /.at.support.util.randomNumberBetween(0, 125); // TODO {IMEI, etc}
		// Current Leader
		def leader := nil;
		// Current Status
		def status := "init"; // {init, joining, inSession, inSessionPlay,...}

		// All players discovered so far
		def players := iterMap.new();
		// Players currently online and playing
		def onlinePlayers := iterMap.new();
		// New/Reconnected Playres waiting to join
		def joinPlayers := iterMap.new(); 
		
		// Local playBoard
		//def board := playBoard.new(rows, cols);

		// Local and remote interfaces
		def local := weLiveLocalInterface.new(self);
		def remote := weLiveRemoteInterface.new(self);
		
		// session
		def sessionID := -1; // to be initialized

		// Export/discover peers
		def goOnline() {
			export: remote as: Player;
			def detectOtherPlayers(time){
				system.println("INFO -- Start detecting other players for " + time + "s");
				// GUI output: scanning for other Players
				when: time elapsed: {
					if: (onlinePlayers.length > 0) then:
					{// Get statusses of other players
						// get a snapshot of current online players
						def currOnlinePlayers := onlinePlayers.deepCopy();
						def statusRequests := group: currOnlinePlayers.map({|plyr| plyr<-getStatus()@FutureMessage});
						when: statusRequests becomes: { |statusses|
							system.println("INFO -- Statusrequests: " + statusRequests);
							def currpos := 1;
							def leaderFound := false;
							def nonInitFound := false;
							{|break|
								// Check if a leader already exists
								statusses.each:{ |plyrstatus|									
									if: (plyrstatus != "init") then: {
										nonInitFound := true;
										def plyr := currOnlinePlayers.at(currpos);
										def plyrleaderID := plyr<-getLeader();
										when: plyrleaderID becomes: { |leaderID|
											if:(leaderID == nil) then: {
												// This player does not have a leader yet -> this is a joiner (because his status != init)

												// ignore
												}
											else: {
												// Check if we already discovered the leader
												def remLeader := players.get(leaderID);
												if:(remLeader != nil) then: {
													// Send joinrequest to discovered leader
													joinRequest(remLeader);
													system.println("INFO -- JoinRequest sent to leader (" + leaderID + ")");
													leaderFound := true;
													break();
												}
												else: {
													// continue iterating
													system.println("WARNING -- Leader (" + leaderID + ") not yet discovered");
													// TODO: restart: peer scanning (-> reset de tabellen en scan opnieuw naar peers (met de hoop om nu wel een leader te vinden))
													};
											};
										};
									}
									else: {};
									currpos := currpos +1;
								};
							}.escape();
							
							if:((!leaderFound).and:{nonInitFound}) then: {// No leader found, although a peer with status non-init has been found
								// Scan again (hopefully we find the leader next time)
								system.println("INFO -- no leader found, init found -> restart detection");
								detectOtherPlayers(playerDetectionTime);
							}
							else: {
								if:(!leaderFound) then:{
									system.println("INFO -- All players are init, no leader found -> peer election");
									// Peer election
									status := "electing";
									peerElection(self, currOnlinePlayers); // do peer election (self = this game)
									}
								else:{// Leader found and join request sent -> ignore
									};
							};
						
						};
					}
					else:{
						system.println("INFO -- No players detected yet " + onlinePlayers.length() + ", restart detection");
						detectOtherPlayers(playerDetectionTime);
					};
				};
			}; // end detectOtherPlayers

			detectOtherPlayers(playerDetectionTime);
			
			//def teso := object:{ 
			//def a := 1;
			//def b(s) {
			//a := 2};
			//};

			//def ts := teso.new();

			// DISCOVERY
			whenever: Player discovered: {|plyr|
				when: plyr<-getID()@FutureMessage becomes: { |remoteID|
					players.put(remoteID, plyr);
					onlinePlayers.put(remoteID, plyr);
					system.println("Newplayer Discovered -- " + remoteID);
				};
			};
		};
		goOnline();
	};
};

def joinRequest(player) {
	player<-requestJoin(ID);
	status := "joining";
};

network.online();
def weLiveCore := makeWeLive();
system.println("weLive started, myId:" + weLiveCore.ID);