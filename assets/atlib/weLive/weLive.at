import ~.iterMap;
import ~.weLiveLocal;
import ~.weLiveRemote;
import ~.playBoard;
import ~.peerElection;
import ~.misc;
import /.at.lang.futures exclude seconds,minutes,millisec;
import /.at.support.timer;

//DIRTY CONSTANTS
def rows := 6;
def cols := 4;
def playerDetectionTime := seconds(5);

deftype Player;
deftype Board;

def makeWeLive(){
	object:{
		// Id of this player
		def ID := /.at.support.util.randomNumberBetween(0, 125); // TODO {IMEI, etc}
		// Current Leader
		def leader := nil;
		// Current Status
		def status := "init"; // {init, joining, inSession, inSessionPlay,...}

		// All players discovered so far
		def players := iterMap.new();
		// Players currently online and playing
		def onlinePlayers := iterMap.new();
		// New/Reconnected Playres waiting to join
		def joinPlayers := iterMap.new(); 
		
		// Local playBoard
		//def board := playBoard.new(rows, cols);

		// Local and remote interfaces
		def local := weLiveLocalInterface.new(self);
		def remote := weLiveRemoteInterface.new(self);
		
		// session
		def sessionID := -1; // to be initialized

		// Export/discover peers
		def goOnline() {
			export: remote as: Player;
			def detectOtherPlayers(time){
				system.println("INFO -- Start detecting other players for " + time + "s");				
				// GUI output: scanning for other Players
				when: time elapsed: {
					if: (onlinePlayers.length > 0) then:
					{// Get statusses of other players
						// get a snapshot of current online players
						def currOnlinePlayers := onlinePlayers.deepCopy();
						def statusRequests := group: currOnlinePlayers.map({|plyr| plyr<-getStatus()@FutureMessage});
						when: statusRequests becomes: { |statusses|
							system.println("INFO -- Statusrequests: " + statusRequests);
							def currpos := 1;
							def leaderFound := false;
							if: (leader != nil) then: {leaderFound := true;}; // FIXME: dirty hack to prevent not detecting to be a leader yourself							
							def nonInitFound := false;
							{|Q|
								// Check if a leader already exists
								statusses.each:{ |plyrstatus|									
									if: (plyrstatus != "init") then: {
										nonInitFound := true;
										def plyr := currOnlinePlayers.at(currpos);
										def plyrleaderID := plyr<-getLeader()@FutureMessage;
										when: plyrleaderID becomes: { |leaderID|
											if:(leaderID == nil) then: {
												// This player does not have a leader yet -> this is a joiner (because his status != init)

												// ignore
												}
											else: {
												// Check if we already discovered the leader
												
												if:(players.contains(leaderID)) then: {
													def remLeader := players.get(leaderID);
													// Send joinrequest to discovered leader
													joinRequest(ID, remLeader, -1);	// -1 = we did not play a session before
													status := "joining";
													system.println("INFO -- JoinRequest sent to leader (" + leaderID + ")");
													leaderFound := true;
													Q();
												}
												else: {
													// continue iterating
													system.println("WARNING -- Leader (" + leaderID + ") not yet discovered");
													// XXX: intussen waarschijnlijk wel al gevonden <<<<<<<<<<<<<<<
													};
											};
										}
										catch: { |e|
											system.println("EXCEPT -- getLeader -- " + e);
										};
									}
									else: {};
									currpos := currpos +1;
								};
							}.escape();
							
							if:((!leaderFound).and:{nonInitFound}) then: {// No leader found, although a peer with status non-init has been found
								// Scan again (hopefully we find the leader next time)
								system.println("INFO -- no leader found, non-init found -> restart detection");
								detectOtherPlayers(playerDetectionTime);
							}
							else: {
								if:(!leaderFound) then:{
									system.println("INFO -- All players are init, no leader found -> we become leader");
									// If no leader is found yet and everyone is @init -> make yourself leader and request an Election
									leader := ID;
									status := "electing";
									broadcastRequestPeerElection(self, leader);
									// !!!!! Check dat je ZELF OOK PEERELECTION doet !!!
									// TODO --> Nieuwe leader moet overnemen en spel starten									
									}
								else:{// Leader found and join request sent -> ignore
									};
							};
						
						}
						catch: { |e|
							system.println("EXCEPT -- statusRequests -- " + e);
						};
					}
					else:{
						system.println("INFO -- No players detected yet: " + onlinePlayers.length() + "waiting for another one to request join");
						//detectOtherPlayers(playerDetectionTime);
					};
				};
			}; // end detectOtherPlayers

			detectOtherPlayers(playerDetectionTime);
			
			//def teso := object:{ 
			//def a := 1;
			//def b(s) {
			//a := 2};
			//};

			//def ts := teso.new();

			// DISCOVERY
			whenever: Player discovered: {|plyr|
				when: plyr<-getID()@FutureMessage becomes: { |remoteID|
					players.put(remoteID, plyr);
					onlinePlayers.put(remoteID, plyr);
					system.println("Newplayer Discovered -- " + remoteID);
				};
			};
		};
		goOnline();
	};
};
// 
def broadcastRequestPeerElection(game, oldLeader){
	if: (oldLeader == game.ID) then: {
		game.onlinePlayers.map({|plyr|
			plyr<-requestPeerElection(oldLeader)@OneWay
			});
	}
	else: {
		system.prinln("ERROR -- Can't request peer election if self != leader");
	};
};


// TODO
def joinRequest(myID, leader, session) {
	leader<-requestJoin(myID, session)@FutureMessage;	
};

network.online();
def weLiveCore := makeWeLive();
system.println("weLive started, myId:" + weLiveCore.ID);