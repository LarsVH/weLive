import ~.iterMap;
import ~.weLiveLocal;
import ~.weLiveRemote;
import ~.playBoard;
import ~.session;
import ~.peerElection;
import ~.misc;
import /.at.lang.futures exclude seconds,minutes,millisec;
import /.at.support.timer;

//DIRTY CONSTANTS
def rows := 6;
def cols := 4;
def playerDetectionTime := seconds(5);
def sessionDurationMillis := seconds(10);
def sessionResumeMillis := seconds(10);
def leaderMarginTime := seconds(2);

deftype Player;
//deftype Board;

def makeWeLive(){
	object:{
		// Id of this player
		def ID := /.at.support.util.randomNumberBetween(0, 125); // TODO {IMEI, etc}
		// Current Leader
		def leader := nil;
		// Current Status
		def status := "init"; // {init, joining, inSession, inSessionPlay,...}

		// All players discovered so far
		def players := iterMap.new();
		// Players currently online and playing
		def onlinePlayers := iterMap.new();
		// Players currently 'in-game' (ONLY LEADER has this map. No longer leader -> make-empty/nil)!!
		def sessionPlayers := iterMap.new();
		// New/Reconnected Playres waiting to join
		def joinPlayers := iterMap.new(); 
		
		// Local playBoard
		def startBoard; // := playBoard.new(rows, cols);

		// Local and remote interfaces
		def local := weLiveLocalInterface.new(self);
		def remote := weLiveRemoteInterface.new(self);
		
		// session.init(sessionID, playBoard, plyrs, endTm, ownerID)
		def currSession := session.new(-1, nil, iterMap.new(), nil);
		
		// Export/discover peers
		def goOnline() {
			export: remote as: Player;
			
			def leaderFound := false;
			def detectOtherPlayers(time){
				system.println("INFO -- Start detecting other players for " + time + "s");
				// GUI output: scanning for other Players
				when: time elapsed: {
					if: (onlinePlayers.length > 0) then:
					{// Get statusses of other players
						// get a snapshot of current online players
						def currOnlinePlayers := onlinePlayers.deepCopy();
						def statusRequests := group: currOnlinePlayers.map({|plyr| plyr<-getStatus()@FutureMessage});
						when: statusRequests becomes: { |statusses|
							system.println("INFO -- Statusrequests: " + statusRequests);
							def currpos := 1;
							if: (leader != nil) then: {leaderFound := true;}; // FIXME: dirty hack to prevent not detecting to be a leader yourself
							def nonInitFound := false;
							{|Q|
								// Check if a leader already exists
								statusses.each:{ |plyrstatus|
									if: (!leaderFound) then: {
										if: (plyrstatus != "init") then: {
											nonInitFound := true;
											def plyr := currOnlinePlayers.at(currpos);
											def plyrleaderID := plyr<-getLeader()@FutureMessage;
											when: plyrleaderID becomes: { |leaderID|
												if:(leaderID == nil) then: {
													// This player does not have a leader yet -> this is a joiner (because his status != init)
													// ignore
													}
												else: {
													// Check if we already discovered the leader
													if:(onlinePlayers.contains(leaderID)) then: {// we already discovered the leader
														def remLeader := players.get(leaderID);
														// Send joinrequest to discovered leader
														joinRequest(ID, remLeader, currSession);//we did not play a session before
														status := "joining";
														system.println("INFO -- JoinRequest sent to leader (" + leaderID + ")");
														leaderFound := true;
														leader := leaderID;
														//Q();
														}
													else: {
														system.println("WARNING -- Leader (" + leaderID + ") not yet discovered");
														// XXX: intussen waarschijnlijk wel al gevonden <<<<<<<<<<<<<<<
														};
												};
											}
											catch: { |e|
												system.println("EXCEPT -- getLeader -- " + e);
											};
										}
										else: {};
										currpos := currpos +1;
									} else: {};// leader found -> done;
									};
							}.escape();
							
							if:((!leaderFound).and:{nonInitFound}) then: {// No leader found, although a peer with status non-init has been found
								// Scan again (hopefully we find the leader next time)
								system.println("INFO -- no leader found, non-init found -> restart detection");
								detectOtherPlayers(playerDetectionTime);
							}
							else: {
								if:(!leaderFound) then:{
									system.println("INFO -- All players are init, no leader found -> we become leader");
									// If no leader is found yet and everyone is @init -> make yourself leader and request an Election
									leader := ID;
									status := "electing";
									broadcastRequestPeerElection(self, leader);
									remote.requestPeerElection(leader);
								}
								else:{// Leader found and join request sent -> ignore
									};
							};
						
						}
						catch: { |e|
							system.println("EXCEPT -- statusRequests -- " + e);
						};
					}
					else:{
						system.println("INFO -- No players detected yet: " + onlinePlayers.length() + "waiting for another one to request join");
					};
				};
			}; // end detectOtherPlayers

			detectOtherPlayers(playerDetectionTime);
			
			// DISCOVERY
			whenever: Player discovered: {|plyr|
				when: plyr<-getID()@FutureMessage becomes: { |remoteID|
					players.put(remoteID, plyr);
					onlinePlayers.put(remoteID, plyr);
					system.println("Newplayer Discovered -- " + remoteID);
				};
			};
			// !!! disconnected werkt enkel op far-refs, niet op typetag => we moeten voor elke player een listener registeren
			// => nieuwe iterMap (ID, listener);
			//whenever: Player disconnected: { |plyr|
			// TODO remove from onlinePlayers
			// TODO remove from Joiners (if exists)
			// TODO remove/doe iets from sessionPlayers
			//};
			};
		goOnline();
		
		// Helpfunctions for onNewLeader()
		//---------------------------------------
		def startNewGame(stBoard, players) {
			system.println("INFO -- (Leader) Starting game");
			def endTime := now() + sessionDurationMillis; // add 10 seconds for the endTime
			currSession := session.new(1, stBoard, players,endTime);
			players.map({|plyr|
				plyr<-startSession(currSession)@OneWay;});
			remote.startSession(currSession);// starting ourselves
			};
		def continueGame(stBoardn, players){ // When a leader has failed
			system.println("INFO -- (Leader) Continuing game");
			def endTime := now() + sessionResumeMillis;
			currSession := session.new(currSession.ID, stBoard, players, endTime);
			players.map({|plyr|
				plyr<-resumeSession(currSession)@OneWay;});
			remote.resumeSession(currSession);// resuming ourselves
			};
		
		
		// New leader
		//---------------------------------------
		def onNewLeader(newLeaderID){
			leader := newLeaderID;// !! Laat dit staan (enkel voor de leader dubbel)
			system.println("DEBUG -- onNewLeader. MyID:" + ID + "; leaderID: " + newLeaderID);
			if: (leader == ID) then: {
				// We are new leader
				// Get all existing sesssionPlayers (< ken je nog niet als je net leader wordt);

				// Go through all onlineplayers and request their session objects
				// Get the one with the highest sessionID
				// deepCopy its' players into sessionPlayers (if exist in onlinePlayers)
				// merge and compute next cycle (based on the highesSessionID object) -> use sessionOver(session)
				def sessionRequests := group: onlinePlayers.map({|plyr|
					 plyr<- getSession()@FutureMessage;
				 });
				 when: sessionRequests becomes: {|sessions|
					 def highestSession := currSession;
					 sessions.each:{|session|
						 if:(session.ID > highestSession.ID) then:{
							 highestSession := session;
						 };
					 };
					def hsPlayers := highestSession.players();// hsPlayers == higest session players (a table)
					if:(hsPlayers.length() > 0) then: {
						sessionPlayers := iterMap.new(); // make sure sessionPlayers is empty
						hsPlayersCopy := hsPlayers.deepCopy();
						hsPlayersCopy.mapkv({|kv|
							if:(onlinePlayers.contains(kv.at(1))) then:{
								sessionPlayers.put(kv.at(1), kv.at(2));
							}
							else: {system.println("WARNING -- newLeader -- a sessionuser went offline");};
							kv;});
						sessionOver(highestSession);
					}
					else: {
						//no sessionplayers exist yet (= no game exists yet)
						// => start new game with all onlinePlayers (clear joinmap)
						system.println("INFO -- No sessionPlayers yet -- starting new game");
						joinPlayers := iterMap.new();// clear joiners
						sessionPlayers := onlinePlayers.deepCopy(); 
						def startBoard := playBoard.new(rows, cols);
						startNewGame(startBoard, sessionPlayers);
					};
				 };
			}
			else: { // Someone else is new leader
				sessionPlayers := iterMap.new();// no leader -> do not keep track of sessionPlayers -> clear
				};
		};
		
		// End-of-Session callback
		def sessionOver(session){
			status := "endOfSession";
			def highestID := ID;	// start with yourself (in case the leader went offline)
			onlinePlayers.mapkv({|kv|
				if:(IDsmaller(highestID, kv.at(1))) then: {highestID := kv.at(1);};
				kv;});
			joinPlayers.mapkv({|kv|
				if:(IDsmaller(highestID, kv.at(1))) then: {highestID := kv.at(1);};
				kv;});
			if: (highestID != leader) then: {	// leader cannot longer be leader
				sessionPlayers := iterMap.new();
				broadcastRequestPeerElection(self, leader);				
			} 
			else: {
				if: (leader == ID) then: {
					when: leaderMarginTime elapsed: {// safety margin (prevent errors caused by connections delays)
						def sessionsFut := group: session.players.map({|plyr|
							plyr<-getSession()@FutureMessage;
						});
						when: sessionsFut becomes: {|sessions|
							system.println("INFO -- leader (" + ID + ") -- retrieved all sessionobjects, starting merge");
							def merged := [currSession.board];// start merging with our playboard
							sessions.each:{|session|
								merged := merge(merged.at(1), session.board);
								// cellsLost1 := merged.at(2);// not taken into account in this version of the game
								// cellsLost2 := merged.at(3);
								};
							def mergedSession := merged.at(1);
							// merge joiners in sessionPlayers
							joinPlayers.mapkv({ |kv|
								sessionPlayers.put(kv.at(1), kv.at(2));
								kv;// mapkv requires a return value
								});
							joinPlayers := iterMap.new();
							def nextSession := session.new((currSession.ID + 1), computeNextGen(mergedSession), sessionPlayers, (now() + sessionDurationMillis));
							sessionPlayers.map({|plyr| plyr<-startSession(nextSession)@OneWay;});
							remote.startSession(nextSession);
						};
						// merge playboards
						// include joiners
						// make new session object (id + 1)
						// start new session

					};
				}
				// Leaderwill retrieve our sessionobject
				// Wait for next session to start
				else:{// GUI: wait for next session
					}; 
			};
		};
	
	
	};
};
// 
def broadcastRequestPeerElection(game, oldLeader){
	if: (oldLeader == game.ID) then: {
		game.onlinePlayers.map({|plyr|
		plyr<-requestPeerElection(oldLeader)@OneWay
		});
	}
	else: {
		system.prinln("ERROR -- Can't request peer election if self != leader");
	};
};

def joinRequest(myID, leaderRef, session) {
	leaderRef<-requestJoin(myID, session)@FutureMessage;
};

network.online();
def weLiveCore := makeWeLive();
system.println("weLive started, myId:" + weLiveCore.ID);